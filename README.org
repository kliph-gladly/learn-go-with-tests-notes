* Learn Go With Tests
Following along with https://quii.gitbook.io/learn-go-with-tests/

** Other resources
*** Simplicity in Go
- https://fasterthanli.me/articles/i-want-off-mr-golangs-wild-ride
  - Interesting how this differs from Rich Hickey's [[https://www.youtube.com/watch?v=SxdOUGdseq4][Simple made Easy]]
  - Interesting how Go appears to expose all the under-the-hood stuff and leaves it up  to the dev to sort it out

* Hello, World
- Had to turn on yasnippet minor mode to have golang completions work
- I have my editor configured to display tabs as two spaces to make golang more accessible for me
- I have opted to edit files directly rather than tangling so that I can get the benefit of LSP integration in golang
  - [ ] There may be a good way to make it work inside Org-mode but I haven't investigated
  - Pretty cool to be able to see compiler errors in the editor without needing to run the tests :sunglasses:

** Go modules
- [ ] Can I get =go test= to report using dots?

To see a module's godocs:

#+begin_src sh
  godoc -http :8000
#+end_src

** Can I watch and rerun tests?
- Not through =go test= directly :(
- I can do some shenanigans with =fswatch= (an OS X tool, similar tools exist for other operating systems)
- Install with =brew install fswatch=

#+begin_src sh
  fswatch -o ./*.go | xargs -n1 -I{} go test
#+end_src

See https://emcrisostomo.github.io/fswatch/usage.html

** Hello, world... again
This is interesting:

#+begin_quote
=t.Helper()= is needed to tell the test suite that this method is a helper. By doing this when it fails the line number reported will be in our function call rather than inside our test helper. This will help other developers track down problems easier.
#+end_quote

This is a feature of Playwright that I prefer as well.

Doesn't look like Go has syntactic sugar for default values for function parameters :( https://stackoverflow.com/questions/19612449/default-value-in-gos-method#comment77755758_23650312

** One last refactor?
Finally breaking code out of this toy function that's already too large and concerned with too much.  The book illustrates that there are implicit returns in golang
#+begin_src go
  func greetingPrefix(language string) (prefix string) {
    switch language {
    case french:
      prefix = frenchHelloPrefix
    case spanish:
      prefix = spanishHelloPrefix
    default:
      prefix = englishHelloPrefix
    }
    return
  }
#+end_src

which will return the =prefix= because it's specified as a named return value to which I say, "Ewww!"  This is a language feature that I would discourage using because it makes it harder to reason about the code inplace.  You need to be aware of the call signature in order to interpret the =return= statement rather than simply interpreting the =return= statement by itself.

See https://github.com/golang/go/wiki/CodeReviewComments#named-result-parameters for more details.

* Integers
#+begin_quote
When you have more than one argument of the same type (in our case two integers) rather than having =(x int, y int)= you can shorten it to =(x, y int)=.
#+end_quote

I found this unclear. I thought it was saying =x= is any type rather than =int=.

** Implementing Repeat
I'd rather use reduce to construct a string like this.  The standard =strings= library https://cs.opensource.google/go/go/+/refs/tags/go1.19.5:src/strings/strings.go;l=528 uses a chunked approach to writing into a =Builder=. Doesn't look like Go has functional constructs like =reduce=.  Maybe there's a more idiomatically functional way to do this rather than imperatively iterating through a loop and concatenating strings.

Ah =make= seems sort of like what I want.  =make= and =range= feel a little bit like initializing a collection and then mapping over a collection to transform it into another collection.

* Arrays And Slices
** Refactoring to use a slice instead of an array of defined size (tuple?)
- [ ] If a function consumes a slice, why can't an array of defined size be passed to it?
  - It seems like something that a [[https://clojure.org/reference/sequences][seq-like abstraction]] could handle
** Coverage
#+begin_src sh
  go test -cover
#+end_src
** Feels like I'd reach for reduce
In order to avoid the kind of error-prone boundary checking, I almost always find it more advantageous to express this sort of computation as a reduce operation over the inputs.

* Structs, methods and interfaces

Made it to https://quii.gitbook.io/learn-go-with-tests/go-fundamentals/structs-methods-and-interfaces#write-enough-code-to-make-it-pass

* An Aside: Understanding go.sum and go.mod file in Go (Golang)
Following along at https://golangbyexample.com/go-mod-sum-module/

- =go.mod= specifies the root of a Go module.
  - It defines the module import path
  - The version of go with which the module was created
  - Dependency requirements for the module (including specific versions)

- =go.sum= lists the checksums of direct and indirect dependencies

#+begin_quote
Also please note that both go.mod as well as go.sum file should be checked into the Version Control System (VCS) such as git
#+end_quote

Note: when following the example, I needed to add =./learn= to the root =go.work= to make the imported dependency resolve properly.  Before I did this, I repeatedly got an error saying that no required module provides the package, even after following the =go get= instructions to install the package.

- [ ] It's not clear to me why I would need to install a package's indirect dependencies.  If they're not necessary to run the code that I'm imported, why would I need them.  If they are necessary, then why aren't they specified among the package's direct dependencies?
